name: Product Service Integration Test

on:
  push:
    branches:
      - main
      - source
    paths:
      - 'server/apps/product-service/**'
      - '.github/workflows/intergration-test-restaurant.yml'
  pull_request:
    branches:
      - main
      - source
    paths:
      - 'server/apps/product-service/**'
  workflow_dispatch:

jobs:
  setup-infrastructure:
    name: Start Docker Compose Stack
    runs-on: self-hosted
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Start Docker Compose Stack
        shell: powershell
        working-directory: server
        run: |
          Write-Host "Checking CN_FoodFast Docker Compose stack..." -ForegroundColor Cyan
          
          $running = docker-compose ps -q 2>$null | Out-String
          
          if ($running) {
            Write-Host "Stack already running, checking health..." -ForegroundColor Green
            docker-compose ps
          } else {
            Write-Host "Starting Docker Compose stack..." -ForegroundColor Yellow
            docker-compose up -d productdb rabbitmq
            
            Write-Host "`nWaiting for services to be ready..." -ForegroundColor Cyan
            Start-Sleep -Seconds 15
          }
          
          Write-Host "`nDocker Compose Services Status:" -ForegroundColor Cyan
          docker-compose ps
          
          Write-Host "`nPostgreSQL Health Check:" -ForegroundColor Cyan
          docker ps --filter "name=productdb" --format "table {{.Names}}\t{{.Status}}"

  product-integration-test:
    name: Product Service Integration Test
    runs-on: self-hosted
    needs: setup-infrastructure
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Install Dependencies
        shell: powershell
        working-directory: server/apps/product-service
        run: npm ci

      - name: Run Integration Tests
        shell: powershell
        working-directory: server/apps/product-service
        run: |
          Write-Host "Starting Product Service Integration Tests..." -ForegroundColor Cyan
          npm run test:integration 2>&1 | Tee-Object -FilePath product-integration-test.log
          exit $LASTEXITCODE
        continue-on-error: true

      - name: Upload test logs
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: product-integration-test-logs
          path: server/apps/product-service/product-integration-test.log
          retention-days: 7

      - name: Push logs to Grafana Loki
        if: always()
        shell: powershell
        working-directory: server/apps/product-service
        env:
          LOKI_URL: ${{ secrets.GRAFANA_LOKI_URL }}
          LOKI_USERNAME: ${{ secrets.GRAFANA_LOKI_USERNAME }}
          LOKI_API_KEY: ${{ secrets.GRAFANA_LOKI_API_KEY }}
        run: |
          $logFile = "product-integration-test.log"
          
          if (-not (Test-Path $logFile)) {
            Write-Host "No log file found, skipping Loki push" -ForegroundColor Yellow
            exit 0
          }
          
          Write-Host "Pushing logs to Grafana Loki..." -ForegroundColor Cyan
          
          # Read log content
          $fullContent = Get-Content $logFile -Raw -ErrorAction SilentlyContinue
          if (-not $fullContent) {
            Write-Host "Log file is empty" -ForegroundColor Yellow
            exit 0
          }
          
          # Extract only summary section (from "Test Suites:" to end) to avoid OutOfMemoryException
          $summaryMatch = [regex]::Match($fullContent, '(?s)(Test Suites:.*)')
          if ($summaryMatch.Success) {
            $logContent = $summaryMatch.Value
            Write-Host "Extracted test summary for Loki push" -ForegroundColor Green
          } else {
            $logContent = "No test summary found in log file"
            Write-Host "Warning: Could not find test summary" -ForegroundColor Yellow
          }
          
          # Prepare Loki push payload
          $timestamp = [DateTimeOffset]::UtcNow.ToUnixTimeMilliseconds() * 1000000
          
          $payload = @{
            streams = @(
              @{
                stream = @{
                  job = "github-actions"
                  service = "product-service"
                  type = "integration-test"
                  repository = "${{ github.repository }}"
                  branch = "${{ github.ref_name }}"
                  commit = "${{ github.sha }}"
                  run_id = "${{ github.run_id }}"
                  workflow = "product-integration-test"
                }
                values = @(
                  @("$timestamp", $logContent)
                )
              }
            )
          } | ConvertTo-Json -Depth 10 -Compress
          
          # Push to Loki
          $headers = @{
            "Content-Type" = "application/json"
          }
          
          $auth = [Convert]::ToBase64String([Text.Encoding]::ASCII.GetBytes("${env:LOKI_USERNAME}:${env:LOKI_API_KEY}"))
          $headers["Authorization"] = "Basic $auth"
          
          try {
            $response = Invoke-RestMethod -Uri "${env:LOKI_URL}" -Method Post -Headers $headers -Body $payload
            Write-Host "Logs pushed to Loki successfully!" -ForegroundColor Green
          } catch {
            Write-Host "Failed to push logs to Loki: $_" -ForegroundColor Red
            # Don't fail the workflow if Loki push fails
          }
